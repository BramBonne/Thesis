\chapter{Session attack countermeasures}

In this chapter, we discuss some general countermeasures to the session hijacking and session fixation attacks. We also briefly describe some solutions to cross site scripting attacks, because of their importance in session attacks. The discussion of more specific countermeasures is deferred to section \ref{related-work}, where we talk about countermeasures related to our own solution. % TODO: check of dit nog overeenkomt met uiteindelijke lay-out

\section{Server-side countermeasures}

This section is dedicated to server-side countermeasures against session hijacking and session fixation. We first describe some general security measures that a web developer can take to secure his web application. Afterwards, we inspect different web frameworks to see how they safeguard against the aforementioned session attacks.

\subsection{General security measures}\label{general-security}

Different security measures may be taken by web application and web framework developers to secure their web applications. In this section, we discuss to what extent these measures provide security against session hijacking and session fixation attacks.

\subsubsection{Renewing the session identifier}\label{renewing}

The practice of renewing the session identifier (see section \ref{renewing-sid}) can provide excellent protection against \gls{login session fixation} attacks. Indeed, if the web application renews the session identifier every time the authentication status of a user changes, the SID which was enforced by the attacker won't be valid anymore once the victim has logged in. As an example, this can be accomplished in PHP by using the following code snippet \cite{PHPregenerate,Johns2011}:

\begin{lstlisting}[language=PHP]
if ($authentication_successful) {
    $_session["authenticated"] = true;
    session_regenerate_id();
}
\end{lstlisting}

To make sure that the session identifier is changed on every authentication change, it can be made to contain specific user information (like the username). In this case, when the authentication state changes, the session identifier has to change, too. If this is used in combination with a server \gls{mac} (as described by Fu et al. \cite{Fu2001}), an attacker is not able to include another username in the value himself.

Renewing the session identifier regularly is also benefical for preventing session hijacking attacks. As was discussed in section \ref{lifetime}, the shorter the lifetime of a session identifier, the more difficult it will be to capture, and the less useful it will be if it has been captured \cite{Fu2001}.

Keeping in mind the previous discussion, one might assume that it is best to renew a session identifier as often as possible. Consider, however, the case where the session identifier is renewed on each request. In this case, every request would result in a new session cookie being set at the user's browser, with the old session cookie being invalidated. When issuing concurrent requests (for example, when loading the images on a web page), the web application would only acknowledge the first request that arrived at the server. The second request would contain the (by then) invalidated session identifier, causing it to be rejected. Because of this, the browser would be allowed to issue only one request at the same time. Similarly, this would pose a problem when browser plugins communicate with the server, as well as with asynchronous requests. Another drawback of this approach is that web applications making use of multiple servers would have to synchronize their users' SID on every request \cite{Dacosta2011}. Otherwise, a user would have to re-authenticate every time a page is served by a different server. A last problem with this approach is that the server must issue an extra write to the database on every request, in order to update the SID.

\subsubsection{Using HttpOnly cookies}\label{httponly}

When setting a cookie in the user's browser, a web server can use the cookie's \texttt{HttpOnly} flag to indicate that the browser should only allow access to this cookie via \gls{http}. As a consequence, script code will not be able to access or edit the value for such cookie, and \gls{xss} attacks can be prevented \cite{HttpOnly}.

Singh et al. have shown that it is sometimes still possible for an attacker to read or manipulate a HttpOnly cookie via JavaScript \cite{Singh2010}. Fortunately, our experiments show that the issue of Firefox allowing cookie writes to HttpOnly cookies has since been solved. However, as we will describe in section \ref{httponlyremark}, we have discovered yet other techniques which allow an attacker to circumvent these browser policies. As such, we must conclude that, while marking a cookie as HttpOnly does prevent an attacker from accessing the cookie via JavaScript, it does not prevent him from using XSS to inject a chosen value for this cookie into the victim's browser.

\subsubsection{Secure connections}\label{ssl}

Secure (\gls{ssl}) connections \cite{Stallings2011} can be used to make sure that a session identifier can not be intercepted by a passive \gls{mitm} attacker. In this case, as already noted in \ref{secure-flag}, care must be taken that cookies can never be sent over an unsecure connection. This can be done by setting the \texttt{secure} flag for cookies that will be used only over a \gls{ssl} connection.

Recently, some work has been done to make deployment of HTTPS more widespread \cite{Hodges2010,Jackson2008}. Unfortunately, there are still some drawbacks to using HTTPS for every page \cite{Adida2008}. At the server side, HTTPS is very costly: every connection needs computationally intensive SSL operations to be performed. At the client side, browser caching works differently under SSL, and websites have to be completely transmitted before they can be rendered (because the validity is checked for the entire page).

\subsubsection{Checking other request headers}

Similar to the \texttt{Cookie} header we discussed in section \ref{cookie-header}, a \gls{http} request can contain many other headers \cite{rfc2616}. Some of these headers provide information that can be used to identify a user. For example, the \texttt{User-Agent} header contains information about a user's browser and operating system, while the \texttt{Accept-Language} header lists the languages the user is willing to receive.

A web server can gain some extra certainty about whether it is interacting with the user corresponding to the session ID in the request by comparing some of the header values to those in the last request with the same session ID. Indeed, because an attacker is probably using a configuration which is different from the victim's, the attacker's requests will have different header values. Thus, when certain header values differ between requests, it is possible that a session hijacking or session fixation attack occurred.

The question is then: which headers could be considered to give enough user-specific information, without changing over time? The \texttt{User-Agent} header is obviously the best candidate. Unfortunately, web proxies are known to modify this header \cite{ShiflettHijacking}. Another header which could be considered is the \texttt{Accept} header, which lists the types of content the user's browser will accept. The problem with this header is that in Internet Explorer, its value can change over time \cite{ShiflettHijacking}. The \texttt{Accept-Language} header could be considered. However, different browsers might have the same default value (\texttt{en-US}) for this header. The same goes for the \texttt{Connection} and \texttt{Cache-Control} headers. Other headers are too susceptible to change, and shouldn't be used.

Another problem with using HTTP headers for this purpose is that they are easily guessed by an attacker. Indeed, for most headers, only few options are possible, with even less options being very probable. Furthermore, even in the case that an attacker would not be able to guess the header values, he only needs to read a single request (to whatever server) from the victim to know what header values to use. He can get a request from the victim by intercepting it, or by tricking the victim into visiting his own website.

Thus, while checking the headers might raise the barrier for attackers, it is by no means a complete solution against any of the described session attacks.

\subsubsection{Checking the IP address}

Similar to request headers, the \gls{ip} address can be used by the web server to ensure it is interacting with the same user as before. Unfortunately, this approach also suffers from some problems. Firstly, IP addresses can be captured in much the same way as HTTP headers. An attacker can then easily change the source IP address for his own packets to impersonate the victim. Secondly, when both the victim and the attacker are behind the same \gls{nat} proxy (as is often the case in session hijacking attacks over a wireless network), they are using the same IP address \cite{Johns2011}. In this case, the server can not distinguish the attacker and the victim based on IP address. Lastly, requiring that the IP address stays the same over time can also cause some problems to the legitimate user: with users changing the location of their notebook or cell phone, the IP addresses of these devices will change when roaming, causing them to be denied access to a web application that checks their IP address. Moreover, some networks only issue dynamic IP addresses to their users. Because of these reasons, it can not be assumed that a user is uniquely tied to a single IP address.

As was the case for checking other request headers, checking the IP address can not be considered a complete solution to any session attack.

\subsubsection{Cookies vs. URL rewriting and form elements}\label{url-vs-cookies}

As we described in section \ref{session-management}, there are three major methods for doing session management: via cookies, via URL rewriting and via form elements. We compare the advantages and disadvantages of these methods here.

A first major disadvantage of URL rewriting was already discussed in section \ref{leaking-via-user}: the session identifier can leak when a link is shared with someone else (for example, via e-mail or a social networking site) \cite{Johnston2004}. A leak can also occur when the \texttt{referer} HTTP header is included in a request to another website: since the URL in the referer header contains the user's session identifier, this identifier is visible to the other website \cite{Fu2001}.

A disadvantage which is shared by both the `URL rewriting' and `form elements' methods is that the injection of a session identifier (with the objective of executing a session fixation attack) requires little effort from an attacker. Indeed, as we saw in section \ref{get-or-post}, such an injection attack is reasonably straightforward.

There is, however, also an advantage of choosing URL rewriting or form elements over cookies, in particular when looking at the cross site request forgery attack. Recall that, to execute a \gls{csrf} attack, an attacker tricks the victim's browser into issuing a request. For this, he  has to create a URL or a form containing the right GET/POST parameters for the attack. However, if the SID is one of the parameters that must be included in the request, the attacker does not know all required parameters, and is therefore not able to create a complete request \cite{Johnston2004}.

It is clear that choosing which method to use for managing sessions requires careful weighing of the advantages and disadvantages of each method. It could be argued that cookies provide more security since they make leaking of session identifiers less likely. Indeed, it is often recommended to use cookies instead of URL rewriting for session management \cite{Zhong2006,Vamosi2006}. An even better option is to use a combination of cookies and POST or GET parameters. As we will see in section \ref{xss-countermeasures}, this is what many CSRF countermeasures try to do \cite{Jovanovic2006,Johns2006}. In addition, some (mobile) web browsers don't support cookies, requiring the use of POST or GET parameters when session management is needed.

\subsubsection{Using an alternative to web sessions}

There are also other -- in some cases more secure -- methods for a web server to know which user it is interacting with. We describe three alternatives to web sessions here.

\paragraph{Logging in for every request}
Arguably the most secure way to determine whether a user is who he claims to be, is to make him enter his credentials for every request. It is obvious that this is very cumbersome for the user, who has to log in every time he requests a new web page. It is, however, good practice to require the user to log in for certain actions \cite{Webers2008}. Indeed, consider the case where an attacker was able to take over a victim's temporary session. If no login is required to change the user's password, the attacker can completely take over the victim's account by changing the password to a value only he knows. Similarly, if the attacker is able to change the victim's e-mailaddress without having to enter the password, he can use the website's password recovery feature to have a password for the user's account sent to his own inbox.

\paragraph{HTTP-Auth}
In HTTP Authentication \cite{rfc2617}, a separate HTTP header (called \texttt{Authorization}) is used to transfer the user's credentials on every request. These credentials are often cached by the browser to relieve the user from having to enter them on every request. A disadvantage of this approach is that the username and password are sent encoded (with the Base64 algorithm) but not encrypted, causing them to be available to a passive \gls{mitm} if no secured connection is used. Another disadvantage is that, since HTTP Authentication is completely handled by the HTTP stack, it is a much less flexible approach than web sessions. For example, there is no easy way for the user to log out, and the server-side HTTP stack needs full access to the user database \cite{Adida2008}.

\paragraph{HTTP-Digest}
HTTP-Digest is a variant of HTTP-Auth that uses encryption instead of just Base64 encoding \cite{rfc2617}.This has the advantage that the user's credentials can not be intercepted by a passive MitM attacker. Unfortunately, this method is vulnerable to \emph{active} MitM attacks. It also suffers from the same inflexibility that is associated with HTTP-Auth.

\paragraph{SSL client certificates}\label{certificates}
When secure sessions (see section \ref{ssl}) are used, mutual authentication can be achieved when both server and client possess a SSL certificate \cite{Park2000}. The problem with this approach is that many clients don't have certificates, and that certificate management is still too difficult for most regular users \cite{Whitten1999}. Moreover, a user needs to have its certificate installed on every device he wants to use to access the web application, which is not practical in the current world where people use smartphones and public computers to access web applications.

\subsection{Session security in web application frameworks}\label{frameworks}

Often, web applications are built on top of a web application framework. A \gls{web application framework} provides a web developer with the core functionality of a web application \cite{Schwartz2010}. This core functionality typically consists of elements like user session management, data persistence, and templating systems used to dynamically render web pages. It is upon the foundations provided by these frameworks that many dynamic web applications are built.

In this section, we describe the measures that are taken in some widely used frameworks to ensure security against session hijacking and session fixation attacks. We consider only the renewing of the SID, the use of secure connections, and the use of cookies or GET and POST parameters, because these are the security measures that are most eligible to be included in a web application framework. The list of frameworks is by no means complete \cite{FrameworksComparison}, but gives a good overview of how popular frameworks handle session attacks.

\subsubsection{Tomcat}

Apache Tomcat\footnote{More information about Tomcat is available on its website: \url{http://tomcat.apache.org/}.} is a much-used software implementation of the Java Servlet and JavaServer Pages technologies. It powers the websites of a.o. WalMart, Wolfram Research and CiteSeerX \cite{TomcatPoweredBy}.

Renewing of the session identifier on authentication is automatically done since Tomcat 6.0 \cite{TomcatAuthentication6}. In previous versions (since 5.5), it is possible to enable this behavior by setting the \texttt{changeSessionIdOnAuthentication} configuration attribute in Tomcat's Authenticator Valve \cite{TomcatAuthentication5}.

Tomcat uses cookies for session management, but also accepts SIDs that are included in the URL. URL rewriting is also used by default when the client's browser does not support cookies. It is possible for a web developer to disable this behavior, and to obligate Tomcat to only accept SIDs in cookies. This is, however, rather cumbersome, because it requires the implementation of a filter that intercepts requests and disables the session IDs from their URLs \cite{Condit2006}.

Secure connections can be managed managed by either the JSSE or the APR \gls{ssl} implementation. To enable Tomcat to use secure connections, the web developer must set the \texttt{protocol} attribute of the Connector configuration entry to use one of these two implementations \cite{TomcatSSL}. A cookie can be set with the \texttt{secure} flag by using the \texttt{setSecure()} method of the \texttt{Cookie} class \cite{TomcatCookie}. Session cookies that are set using a HTTPS connection automatically have the \texttt{secure} flag enabled \cite{Funk2004}.

\subsubsection{Alfresco}

Alfresco\footnote{More information about Alfresco is available on its website: \url{http://www.alfresco.com/}.} is a complete content management system that runs on a J2EE application server like Tomcat \cite{TomcatPoweredBy}. It is used by companies like France AirForce, Cisco, Fox and KLM \cite{AlfrescoPoweredBy}.

Alfresco neglects to renew a user's session identifier when he logs in. We tested the behavior using Alfresco's demo server\footnote{An account for the demo server can be obtained from \url{http://www.alfresco.com/try/}.} and found that a session fixation attack is, indeed, possible. Further investigation showed that a bug which addresses this issue was already reported \cite{AlfrescoSessionFixation}. Unfortunately, the bug already dates from October 2008 and has not been solved since. Requesting more information about session management in Alfresco on IRC or the forums proved fruitless.

If Alfresco is deployed on top of Tomcat, session management and secure connections work in much the same way as they do in Tomcat.

\subsubsection{Ruby on Rails}

Ruby on Rails\footnote{More information about Ruby on Rails is available on its website: \url{http://rubyonrails.org/}.} (or RoR) is a web framework written in the in 1995 conceived Ruby programming language. It is used in popular web applications like Twitter, Groupon and Github \cite{RailsApps}.

Renewing the session identifier is not automatically done on each authentication state change in RoR. There is, however, a supported way of implementing this: invalidating the SID can be done by adding \texttt{reset\_session} to the \texttt{SessionsController\#create} action \cite{Webers2008}. The official documentation advertises this solution as only requiring one line of code, but mentions that session state must still be manually copied.

RoR supports only cookie-based session management by default. If the web developer wants to use URL rewriting instead, he needs to specifically enable this \cite{McMahon2010}.

To make a RoR web application use secure connections for certain pages, the \texttt{ssl\_requirement} plugin\footnote{The \texttt{ssl\_requirement} plugin is available at \url{https://github.com/rails/ssl_requirement}.} can be used. This plugin allows to specify for which pages the HTTPS protocol should be used \cite{Slater2008}. Making sure that certain cookies are only sent over secured connections only requires the configuration option \texttt{ActionController::Base.session\_options[:secure]} to be set to \texttt{true}.

\subsubsection{Django}

Django\footnote{More information about Django is available on its website: \url{http://www.djangoproject.com/}.} is a web framework built using the Python language. It is used by a.o. Ars Technica and The Washington Post \cite{DjangoPoweredBy}.

Django renews the session identifier automatically when a user logs in. For this, two possible cases are considered \cite{DjangoLoginCode}:
\begin{itemize}
	\item If the login request contained a session identifier that corresponds to another logged in user, a completely new session is created.
	\item If the login request contained a session identifier that is not yet associated with a logged in user, a new \emph{SID} is created. This SID is then associated with the state corresponding to the old SID \cite{DjangoSessionsCode}. The old SID is removed from the database, so it can not be used in the future to access the session information.
\end{itemize}

SIDs are only accepted via cookies in Django. This is a very clear-cut design decision \cite{DjangoSessions}, and requires the web developer to write its own middleware if he wants to use POST or GET parameters instead \cite{Fairs2007}.

Secure connections are handled by the underlying web server, and configuring certain pages to require HTTPS connections should be done in the configuration files for the web server. However, to make sure that Django will set the secure flag for all session cookies, the setting \texttt{SESSION\_COOKIE\_SECURE = True} should be added to Django's \texttt{settings.py} \cite{Barnham2009}. This configuration setting is disabled by default \cite{Holovaty2008}.

\subsubsection{CherryPy}

CherryPy\footnote{More information about CherryPy is available on its website: \url{http://cherrypy.org/}.} is another web framework built using Python. It tries to make building web applications as similar as possible to developing any other object-oriented Python program.

The CherryPy documentation claims that CherryPy provides protection against session fixation attacks \cite{CherryPySessions}. However, in reality, only crafted session identifiers are prevented. Indeed, it is still possible for an attacker to establish a session himself, and to impose this session on a victim. To execute a successful login session fixation attack, the only thing required is that some data is tied to the attacker's session. The fact that CherryPy is vulnerable to session fixation attacks was already discovered earlier by Schrank et al. \cite{Schrank2010}.

CherryPy manages session exclusively via cookies \cite{CherryPySessions}. As a consequence, session identifiers will not be accepted as GET or POST parameters.

As with Django, secure connections are handled by the underlying web server. By default, CherryPy does not set the \texttt{secure} flag for any cookies. To enable this flag for all session cookies, the session object should be initialized (by calling \texttt{cherrypy.lib.sessions.init()} with the \texttt{secure} parameter set to \texttt{True} \cite{CherryPySessions}.

\subsubsection{PHP}

PHP\footnote{More information about PHP is available on its website: \url{http://php.net/}.} is a scripting language used for web development. We include this discussion of PHP's session module in this section because PHP is estimated to be the server scripting language for over 75\% of all websites \cite{ServerSurvey}.

Since PHP only supports the concept of sessions, and not that of users, there is no way for PHP to know when the authentication state changed. As such, PHP does not renew the session identifier automatically when needed. Session fixation prevention can however be easily implemented by calling the \texttt{session\_regenerate\_id()} function every time a user's authentication state changes, similar to the code snipped provided in section \ref{renewing}.

PHP uses cookies by default for session management, but also accepts session identifiers passed via URLs  \cite{Holovaty2008}. To change this behavior, the line \texttt{php\_flag session.use\_trans\_sid\ off} should be set in the \emph{web server's} \texttt{.htaccess} configuration file, or the line \texttt{ini\_set('session.use\_trans\_sid', false)} should be added to the PHP code. Note that the previous example only works when the Apache web server is used to serve the PHP pages (which is most often the case) \cite{PHPdisableURL}.

To use secure connections, PHP must be compiled with the \texttt{--with-openssl} parameter. To make sure that PHP sets the \texttt{secure} flag for all session cookies, the \texttt{session\_set\_cookie\_params()} function must be called with the parameter \texttt{secure} set to \texttt{true} for every request \cite{PHPsessionCookieParams}. By default, cookies don't include the \texttt{secure} flag.

\subsubsection{Drupal}

Drupal\footnote{More information about Drupal is available on its website: \url{http://drupal.org/}.} is a complete content management system written in PHP. It powers the websites of The Economist, Symantec, and even The White House \cite{DrupalCases,DrupalWhiteHouse}.

Drupal automatically renews the session identifier when the user's authentication state changes \cite{DrupalAuth}. It does this by calling PHP's \texttt{session\_regenerate\_id()} function \cite{DrupalRegenerate}. While this has always been the default behavior of Drupal, some bugs were still present in versions preceding Drupal 5.9 and 6.3 \cite{DrupalBug}.

Drupal makes sure that PHP's underlying session mechanism will only accept session IDs via cookies. It does this by calling the previously described \texttt{ini\_set()} function with the relevant parameters during initialization \cite{DrupalSettings}. Unfortunately, some problems are still known to occur for some web hosts, where the relevant parameters should be added to PHP's \texttt{.htaccess} file manually \cite{DrupalSIDurl}.

Secure connections and secure cookies in Drupal are handled via PHP's mechanisms. However, Drupal's `Secure Login' module can be used to force certain pages to be loaded via HTTPS \cite{DrupalSecureLogin}. To make sure that every cookie set over HTTPS has the \texttt{secure} flag enabled, this module also sets the \texttt{session.cookie\_secure} flag to \texttt{true} since Drupal 7.

\subsubsection{Overview}

An summary of session security in the discussed web application frameworks is given in Table \ref{tab:frameworks}. As we can see, the popular high-level frameworks in our list (RoR, Drupal, Django) provide pretty good protection against session attacks, which reinforces our recommendation to use a high-level framework whenever possible (see section \ref{use-framework}). However, care must be taken that the framework is configured correctly.

\begin{table}[ht]
	\centering
	\begin{tabular}{r|ccc}
		& Renews SID & Only accepts & \texttt{secure} flag for\\
		& on auth & cookie-based SIDs & SSL session cookies\\
		\hline
		Tomcat & since version 6 & implementable & default\\
		Alfresco & no & implementable & default\\
		RoR & configurable & yes & configurable\\
		Django & yes & yes & configurable\\
		CherryPy & no & yes & configurable\\
		PHP & no & configurable & configurable\\
		Drupal & since version 5.9/6.3 & yes & via module\\
	\end{tabular}
	\caption{Session security in different web application frameworks}
	\label{tab:frameworks}
\end{table}

\subsection{Stand-alone server countermeasures}\label{standalone-server}

In this section, we describe some general server-side countermeasures to session hijacking and session fixation which are not part of any web framework.

\subsubsection{Deferred loading (SessionSafe)}

SessionSafe is a combination of different solutions to session attacks proposed by Johns et al. in 2006 \cite{Johns2006}. One of these, called `deferred loading', was created specifically for session hijacking.

The reasoning behind deferred loading is that cookies should be separated from the content of a page, to prevent an attacker from using the page content to steal the cookie. It does this by setting the cookie on a different subdomain (\url{secure.example.org}) than the web page itself (\url{www.example.org}). A page is then requested as follows:
\begin{enumerate}
	\item Instead of getting the page directly, the user's browser requests a `page loader' from the server. This page loader is a small HTML page that contains logic which will be executed at the client side to fetch the actual page.
	\item The page loader makes the browser send the user's cookie to \url{secure.example.org}, and a request for the actual page to \url{www.example.org}. In both requests, the browser includes the same request ID, which was sent by the server as part of the page loader.
	\item The web server checks that the cookie is correct, and that both requests were issued with the same request ID (and thus by the same page loader). If this is the case, it sends the requested web page as a response, and it invalidates the request ID for future requests.
	\item The page loader displays the actual web page in the user's browser.
\end{enumerate}
Because cookies are set for a different domain than the one web pages are served from, script code which is included in a web page on \url{www.example.com} has no access to cookies stored on the \url{secure.example.com} domain. This prevents attackers from injecting script code (via a \gls{xss} attack) which steals a user's cookie.

Note that this approach does not prevent the attacker from executing a session fixation attack. Indeed, although script code is unable to access cookies stored in a different subdomain, it \emph{is} able to set cookies for its parent domain, as was discussed in section \ref{subdomain-setting}. This allows an attacker to inject script code in a page hosted on \url{www.example.org} that sets a cookie for the domain \url{example.org}. Since \url{secure.example.org} is also a subdomain of \url{example.org}, requests made to this domain will contain the injected cookie.

\subsubsection{SessionLock}%TODO

SessionLock (proposed by Adida et al. in 2008 \cite{Adida2008}) tries to solve session hijacking by making session identifiers only available at the client side. For this purpose, fragment identifiers are used.

Fragment identifiers are included in the URL specification \cite{rfc3986} as a means for making the user's web browser scroll to a certain part of a web page. The fragment identifier is included in the URL as the part that follows the \texttt{\#} character. For example, the URL \url{http://www.example.org/document.html#paragraph4} has \texttt{paragraph4} as its fragment identifier. Loading this URL in the browser will cause the browser to request \emph{document.html} from the web server, and to jump to the element on that page which is identified by the string \texttt{paragraph4}. If no such element is available on the page, the web browser will simply ignore the fragment identifier part of the URL. Fragment identifiers are not sent to the web server on a request, but are available to client-side JavaScript via the \texttt{document.location.hash} \gls{dom} element.

It is in such a fragment identifier that the user's SID will be stored. Interaction between the user's browser and the server happens in the following steps:
\begin{enumerate}
	\item The user authentication happens over a secure (\gls{https}) connection. When the authentication is successful, the web server redirects the user to a URL that includes the SID as its fragment identifier.
	\item Subsequent requests are made over an unsecure (\gls{http}) connection. In every request, the user's browser attaches a \gls{mac}, generated with the (secret) SID, of the tuple \emph{(request-URL, timestamp)}. To avoid having to modify the browser, this is achieved by including a small piece of JavaScript code in the page which intercepts all user requests. The JavaScript code then attaches a timestamp and MAC to every request before it is forwarded to the server.
\end{enumerate}

%By doing this, a \gls{mitm} attacker is not able to capture the session identifier since it is never sent over any connection. Note that it is important that the authentication happens over a secure connection, since the SID would otherwise still be visible on the network when it was set. Although solution in paper which doesn't require SSL, requires Diffie-Hellman [5]

To make sure that the SID is remembered at the client side, JavaScript code is included in every page returned by the server. This code rewrites every URL on the page to include the SID as a fragment identifier. Note that the server cannot rewrite these URLs itself, because then the SID would be visible on the network when the page is returned to the client.

\subsubsection{One-time cookies}

In a paper written by Dacosta et al. \cite{Dacosta2011}, a solution to session hijacking is proposed wherein session identifiers are replaced by one-time cookies which are renewed on every request. This is done as follows:
\begin{enumerate}
	\item The user authentication happens over a secure (\gls{https}) connection. In this authentication, a secret seed and a session secret are generated.
	\item Subsequent requests are made over an unsecure (\gls{http}) connection. In the $i$-th request, the user's browser attaches the outcome of a hash function  applied $i$ times to the secret seed. Also attached is the current sequence number ($i$, in this case), the user's username, a nonce, and -- most importantly -- a \gls{mac}, generated with the session secret established as part of the authentication, of the triplet \emph{(username, request-URL, hash outcome)}.
\end{enumerate}
It is crucial that the server allows only requests containing a sequence number higher than the last one received. This prevents attackers from replaying captured one-time cookie information. Since the attacker does not know how to generate the next one-time cookie from a previously captured one, and because a previous cookie can not be replayed, the approach renders a captured cookie essentially worthless. Moreover, the request-URL is included in the MAC to make sure that a certain one-time cookie can only be used to access one specific resource.

Aside from preventing session hijacking attacks, this approach will also prevent session fixation attacks. Indeed, as soon as the user authenticates, a new session secret and secret seed -- both unknown to the attacker -- are established. This is similar to renewing the SID on every authentication change.

Because the sequence number is part of the request, the server knows how many times the hash function should be applied to the secret seed. Naturally, the server does not need to apply the hash function $i$ times for every request. Indeed, the computational overhead can be greatly reduced by remembering the previous value, and applying the hash function only $i - i'$ times (where $i'$ is the number of times the function was applied to the previous value) to this previous value.

A major advantage of this approach is that, while users use HTTPS to authenticate (and thus never have their password sent in clear text), a secure connection is not required for subsequent requests. This eliminates the biggest drawback associated with using SSL, namely that of high costs (see section \ref{ssl}).

Possible disadvantages of an approach that uses a new SID for every request were already discussed in section \ref{renewing}. However, two of these do not apply to this particular solution. Firstly, because future SIDs don't need to be explicitly issued by the server, problems with concurrent requests can be avoided by equipping every request with a higher sequence number than the previous one. Secondly, server synchronization is less of a problem because servers could be allowed to only check that a received sequence number is higher than the last one they received themselves. Note that this would permit an attacker to replay a one-time cookie, as long as he issues the request to a server different from the one the user issued his request to. Fortunately, the damage is limited by the fact that the one-time cookie can only be used to access one specific resource. If this policy is applied, synchronization between servers would be limited to the moment a user authenticates.

There are also some other disadvantages of one-time cookies. Compared to using regular session IDs over an unencrypted connection, both the client and the server need to perform more computations, and both have to keep more state. However, as is shown in the paper, using secure connections for every request is still much more computationally intensive \cite{Dacosta2011}. Thus, requiring some extra computation compared to using regular session IDs over an unencrypted connection could be considered a minor trade-off to be able to provide secure user authentication.

The paper also describes that in the current implementation, both the server and the client need to be adapted to support one-time cookies. The authors are, however, exploring the idea of modifying one-time cookies to provide a version that does not require a browser extension \cite{Dacosta2011}.

\subsubsection{Session fixation solution by Johns et al.}%TODO

\cite{Johns2011}

\section{Client-side countermeasures}%TODO

\subsection{SessionShield}\label{sessionshield}

\cite{Nikiforakis2010}

\subsection{Noxes}

\cite{Kirda2006}

\section{Cross site scripting countermeasures}\label{xss-countermeasures}
% Check referrer
% Use asynch requests XDomainRequest, CORS, PostMessage
% \subsubsection{Subdomain switching (SessionSafe)}%TODO
\begin{comment}
\section{Cross site request forgery countermeasures}
\subsubsection{One-time URLs (SessionSafe)}

The second solution proposed by Johns et al. \cite{Johns2006} is that of one-time URLs (not to be confused with one-time cookies described earlier). In this approach, cookies are stored as private variables of JavaScript objects. This makes them unavailable to attackers using JavaScript.
\end{comment}

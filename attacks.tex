\chapter{Session attacks}\label{attacks}

Now that we know how web sessions work, we look into ways in which attackers are able to abuse them. In this chapter, we will see how an attacker can exploit security issues in session management mechanisms in order to impersonate a legitimate user on a website. The discussion of mitigating these attacks is deferred until the next chapter.

\section{Background: cross-site scripting}\label{xss}

Cross-site scripting (or \gls{xss}) \cite{DiLucca2005} is not a session attack in itself. Instead, it is the exploitation of a vulnerability in the way user input is handled within certain web applications. The attack can be of great use when executing one of the actual session attacks described afterwards.

In a cross-site scripting attack, the attacker exploits a vulnerability in a web page to inject his own JavaScript code into this page. The injected code will then be executed in the browser of any user that loads the vulnerable page.

\subsection{Variants of cross-site scripting}
There are two forms of cross-site scripting: persistent and reflected XSS. In this subsection, we describe their differences and give some examples of possible attack scenarios for each of them.

\subsubsection{Persistent (stored) XSS}
In a persistent XSS attack, the attacker misuses a website's functionality that allows users to provide their own content. This allows him to make the web server persistently store his script code, and to make it serve this code to other users later on. The complete scenario goes as follows:

\begin{enumerate}
	\item The attacker provides his malicious code as input to the web application.  The web server stores this input (and thus the script code) in its database.
	\item The victim requests a page containing content provided by the attacker. The server returns the page containing the attacker's JavaScript.
	\item The victim's browser sees the script code as part of the requested web page and executes it.
\end{enumerate}

This attack variant is graphically illustrated in Figure \ref{fig:persistent-xss}.

\begin{figure}[htb]
	\centering
	\subfloat[persistent]{
		\label{fig:persistent-xss}
		\includegraphics[width=.45\textwidth]{img/persistent-xss.png}
	}
	\subfloat[reflected]{
		\label{fig:nonpersistent-xss}
		\includegraphics[width=0.45\textwidth]{img/nonpersistent-xss.png}
	}
	\caption{The cross-site scripting attack}
\end{figure}

An example of a web application that will store user input in a database to serve it to other clients later on is a bulletin board (phpBB\footnote{phpBB is free and open source bulletin board software, available at \url{http://www.phpbb.com/}} is a well-known example). In such a web application, a user can create forum posts which can be read by other users. When an attacker inserts script code into a forum post, the code will be executed by the browser of every user that reads the post.

A more recent example of web applications serving user generated content is found in social networking sites like Facebook\footnote{Facebook is currently the most popular social networking site. It can be found at \url{http://www.facebook.com/}}. Here, a user can place information on his own page, or on the pages of other people. This information will then be served to the user's friends.

\subsubsection{Reflected (non-persistent) XSS}
In a reflected XSS attack, the script code is not stored at the server. Instead, code that was part of a request is immediately reflected back to a client's browser as part of the response page. The complete scenario is as follows:

\begin{enumerate}
	\item The attacker tricks the victim into opening a malicious link containing script code.
	\item The victim opens the link, and unknowingly makes a request containing script code to the server.
	\item The server reflects this script code back to the victim as part of the response.
	\item The victim's browser sees the script code as part of the requested web page and executes it.
\end{enumerate}

This attack variant is graphically illustrated in Figure \ref{fig:nonpersistent-xss}.

An example of a web page returning user input is a search form which displays the search query as part of the response. If it does this without stripping any script data that might be embedded in the query, the web page is vulnerable to reflected XSS attacks \cite{Vogt2007}. To see why, consider the scenario where doing a search for \emph{query} by going to the URL \url{http://www.trusted.com/search?q=query} makes the website return ``x results for \emph{query}''. In this case, the attacker can replace \emph{query} by script code that will be executed by the browser of the client that opens the link. The attacker can then trick a user into clicking the malicious link, causing the JavaScript code to be executed in his browser.

Another example of a scenario where a web application might return data present in the URL is the `Page not found' error page \cite{Kirda2006}. Here, the name of the page that could not be found is often included as part of the error message. Thus, an attacker can craft a link wherein a page with name \texttt{<script>alert("XSS succeeded");</script>} is requested. The browser of a client opening this link will then execute the JavaScript code provided by the attacker.

Tricking a user into clicking a link can be achieved by executing a \gls{phishing} attack \cite{Dhamija2006}. In such an attack, the victim is lead on to believe that the attacker is a known trusted party (e.g. the victim's bank). The attacker, can then ask the victim to click a link under a false premise. Because the victim thinks he can trust the source of the link, he will be inclined to click it. If the link contains malicious data (as is the case in a reflected XSS attack), the victim will unknowingly send this data to the server.

\subsection{Including the script code}\label{injecting-script}
There are multiple ways in which script code can be included in a web page. Since all of these can be leveraged by an attacker to inject his code, it is important that web developers are aware of all of them. T. Jim et al. give a good overview of different approaches to including JavaScript code \cite{Jim2007}. We describe the most important ones, including one that wasn't presented in \cite{Jim2007}, here:
\begin{description}
	\item[between \texttt{<script>} tags] This is the most obvious way of including JavaScript in a web page. All code between these tags will be executed as soon as the browser encounters it.
	\item[using the \texttt{<script>} tag's \texttt{src} parameter] This parameter can be set to point to an external piece of JavaScript. As such, an attacker is able to make a website load JavaScript code from another domain. This method of injecting script code gives the attacker the advantage that the actual injected string is shorter, bypassing message length limits. Furthermore, because the attacker keeps control over the source of the script code now, he is able to edit this code afterwards.
	\item[as the URL of the background image] An attacker can insert a tag similar to \texttt{<div style="background-image: url(javascript:alert('XSS');" />} or \texttt{<style>.bar\{background-image:url("javascript:alert('XSS');");\}</style>} (where \texttt{bar} is the class of an object in the page) to make the browser execute JavaScript, thinking it is loading the background image for the particular object.
	\item[using JavaScript handlers for page elements] It is possible to specify script code that should be triggered when a certain action occurs on an element in a web page. For example, the \texttt{onload} parameter of the \texttt{<body>} tag is used to specify a JavaScript function that should be executed when once the browser has completed loading the page. Two other examples are the \texttt{onclick} and \texttt{onblur} parameters, which can be specified for different kinds of tags, with \texttt{<p>} (which indicates a paragraph) and \texttt{<a>} (which indicates a link) being two possibilities. These parameters specify, for a certain object on the page, respectively the JavaScript function to be executed when the object is clicked, and the function to be executed when the object loses focus.
	\item[via binary objects] If an attacker is able to include a binary object into the page, he can use this object to execute JavaScript code \cite{Bisht2008}. Flash applets, for example, allow running JavaScript code by using either the \texttt{getURL()} or the \texttt{fscommand()} function \cite{FlashJSattack,FlashJS,FlashCookie}.
\end{description}

It must also be noted that attackers can use different possible encodings to inject JavaScript, so as to circumvent server-side JavaScript checkers, while still being able to execute at the client side \cite{Jim2007}. For example, the encoding of (parts of) a web page can be changed using the \texttt{encoding} and \texttt{charset} attributes of various \gls{html} tags \cite{Ishida2010}. Some browsers also allow strings to contain JavaScript that is split over multiple lines \cite{Jim2007}. Lastly, JavaScript can be split over multiple  \texttt{<![CDATA[\dots]]>} tags, making it much harder to detect.

\subsection{The danger of cross-site scripting}\label{xss-problem}

One danger of persistent XSS is immediately clear: websites which do not belong to an attacker can still be abused by the attacker to execute malicious code at a user's browser. The user, thinking that a trusted site will only execute trusted code, can fall victim to the attacker without expecting it.

There is, however, a bigger problem which applies to both persistent and reflected XSS attacks: the problem of cross-domain interactions. Normally, the attacker's code would be subject to the \gls{sop} (described in section \ref{sop}), making him unable to access elements of a domain that he does not own. However, when the attacker's code is able to execute from within a trusted domain (as is the case in an XSS attack), the code is allowed to access elements belonging to that domain \cite{Klein2002}. This gives the attacker the ability to read information from, and write information to, elements in the trusted domain. To see why this is such a big issue, consider the case where an attacker injects code into a trusted domain that reads information from this domain, and subsequently sends the information to the attacker's web server. Sending this data can be done, for example, by having JavaScript open a window containing a page from the attacker's domain with the data as a GET parameter \cite{Klein2002}. These cross-domain interactions are a major attack vector for both the session hijacking and the session fixation attacks, as we will see in the next sections.

\section{Session hijacking}\label{hijacking}

In the session hijacking attack, an attacker tries to take over a victim's session by capturing the victim's \gls{session id}. He then uses the SID to make the server think that he is the victim. This causes him to be able to, for example, read the victim's e-mail in a webmail application, change the victim's information on a social networking website, or acquire the victim's credit card information in an on-line shop. First, we describe the attack scenario. Afterwards, we will see how the attacker can capture the victim's session ID.

\subsection{Attack scenario}

The session hijacking attack works as follows \cite{Nikiforakis2010}:

\begin{enumerate}
	\item The victim establishes a new session at the server. This is done automatically either when he first visits the page or when he logs in (depending on the web application), as described in the previous chapter.
	\item The attacker captures the session ID that corresponds to the victim's created session. The methods that can be used to do this will be described in the next section.
	\item The attacker makes a request to the server, attaching the captured session ID as his own. Because the server has no other effective\footnote{We use the term `effective' here because, as we will see in section \ref{general-security}, there are some other -- unsatisfying -- means for distinguishing between different clients.} means of distinguishing between the victim and the attacker, it thinks that it is the victim who made the request. Thus, the attacker is now able to impersonate the victim at the server.
\end{enumerate}

These steps are graphically illustrated in Figure \ref{fig:hijacking}.

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.50\textwidth]{img/hijacking.png}
	\caption[The session hijacking attack]{The session hijacking attack for a web application that uses cookies}
	\label{fig:hijacking}
\end{figure}

\subsection{Capturing the session ID}\label{capturing}

There are lots of possible ways in which an attacker can capture a victim's session ID. We list the most important ones here.

\subsubsection{Via a (passive) man-in-the-middle attack}

In a man-in-the-middle (or \gls{mitm}) attack, an attacker is able to read traffic that passes between the victim and the server. A common example is when the victim and the attacker are sharing the same network hub, or when they are both connected to the same WiFi hotspot without using WPA2 encryption \cite{Arana2006}.

As was mentioned in section \ref{secure-flag}, the session identifier is, by default, sent over the network as an unencrypted string of text. This is the case both when using cookies as when making use of URL rewriting or form elements. Because of this, an attacker able to read all network traffic can easily extract the SID from the \texttt{Cookie} header, request URL or request data in one of the user's requests, or even from the \texttt{Set-Cookie} header or the response page in the server response setting the cookie \cite{Adida2008}.

This problem has been known for some time, and has recently again received some attention thanks to tools like Hamster \cite{Graham2007} and Firesheep \cite{Butler2010}, which make a session hijacking attack almost trivial when the victim is using an insecure network.

\subsubsection{Via cross-site scripting}

The \gls{xss} attacks can also be used to steal a victim's session ID. For this, the attacker uses one of the methods described in section \ref{injecting-script} to inject script code into a web page on the domain he wants to acquire the cookie from. Because the script code is loaded from within a page on the target domain, the attacker has access to both the target domain's cookie via the \texttt{cookie} attribute of the \texttt{domain} \gls{dom} object (for SIDs set in cookies), and to all links on the current page (for SIDs used via URL rewriting). However, the script is also able to send data to the attacker's domain (see section \ref{xss-problem} and \cite{Klein2002} for more information). Because of this, the attacker is able to forward the target domain's cookie, or an URL present on a page of the target domain, to his own domain, effectively capturing the client's SID.

\subsubsection{Via the referer header}\label{leaking-via-referer}

If SIDs are included in the URL (as is the case with URL rewriting), the SID can also leak via the HTTP \texttt{referer} header. The \texttt{referer} header is used to transmit the website from which the request-URL was obtained to the web server that the request is issued to \cite{rfc2616}. When the browser attaches a \texttt{referer} header to requests going to a different domain than the one it originated from, the website receiving the \texttt{referer} header as part of the request can extract the client's SID for the web application that contained the link to the requested page \cite{Fu2001}.

If, for example, a social networking website manages sessions via URL rewriting, an attacker could perform a session hijacking attack by sharing a link to his own website. When another user clicks the link, a request is made to the attacker's web server. This request contains the URL of the current page, and thus the user's SID for the social networking website, in the \texttt{referer} header, making it available to the attacker.

Sometimes, the \texttt{referer} header is suppressed in the network or by the browser, especially for cross-domain requests \cite{Barth2008}. Unfortunately, the percentage of requests where the \texttt{referer} header is stripped is still small enough to consider leaking of SIDs via this channel a significant threat.

\subsubsection{Via the user}\label{leaking-via-user}

Lastly, it is also possible that the user unknowingly leaks his own session identifier. This is the case when the user shares a link to a page of a web application that uses URL rewriting \cite{Johnston2004}, for example via email or via a social networking site. When another user clicks the shared link, this second user will automatically take over the first user's session. Thus, the second user essentially performs a session hijacking attack on the first user, possibly without even realizing it.

This problem, together with the possibility of leaking SIDs via the \texttt{referer} header, provides a strong argument against using URL rewriting for session management. There are, however, also some advantages of using URL writing instead of cookies, as we will see in section \ref{url-vs-cookies}.

\section{Session fixation}\label{fixation}

In the session fixation attack, as in the \gls{session hijacking} attack, an attacker's goal is to be using the same session as a victim. However, instead of capturing the victim's \gls{session id} (as is the case with session hijacking), the attacker forces the victim to use a SID that is known in advance. We will first describe the steps necessary to execute this attack. Afterwards, we list the ways in which the attacker can force a victim to use a certain session ID.

\subsection{Attack scenario}\label{fixation-scenario}

The session fixation attack works as follows \cite{Kolsek2002}:

\begin{enumerate}
	\item The \emph{attacker} establishes a new session at the server. He does this by sending a request that does not include a SID, which will cause the server to attach a newly generated
SID to the response. Some servers also accept crafted SIDs\footnote{By crafted SIDs, we mean that these SIDs don't need to be generated by the server in advance. A crafted SID can be sent by a user on his first request to make the server `adopt' the SID for this user.} \cite{Shiflett2004}. In this case, the attacker can just make up a new SID, and no request needs to be made.
	\item The attacker forces the victim to use the newly created session ID. The methods that can be used to do this will be described in the next section.
	\item The victim uses his credentials to log in at the server. The SID that was injected at the client's web browser will automatically be attached to the request. There now exists a session at the server, identified by the SID known to the attacker, in which the victim is logged in.
	\item The attacker makes a request to the server, attaching the captured session ID as his own. This makes the server think that it is the victim that made the request. As such, the attacker is able to impersonate the victim at the server.
\end{enumerate}

These steps are graphically illustrated in Figure \ref{fig:fixation}.

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.50\textwidth]{img/fixation.png}
	\caption[The session fixation attack]{The session fixation attack for a web application that uses cookies}
	\label{fig:fixation}
\end{figure}

\subsection{Injecting a session ID}\label{injecting-sid}

In this section, we describe the most important attack vectors which can be used by an attacker to inject a session ID into the victim's browser.

\subsubsection{Via GET or POST parameters}\label{get-or-post}

If the target website accepts session ID's in \glspl{url} (see section \ref{session-management}), the attacker can craft a link of the form \url{http://www.target.com/login.php?PHPSESSID=d9qX4zKbg35}, where he chooses the desired session ID \cite{Johns2011}. He then sends this link to the victim, or places it on the target website as part of an \gls{xss} attack. When the victim clicks the link, the request sent to the target server contains the attacker's SID in the URL, causing the web application to think it is the victim's session ID. Alternatively, the attacker can force the victim to visit the URL by using an HTTP redirect \cite{rfc2616} to make the victim's browser automatically load the page \cite{Shiflett2004}. This requires the victim to visit the attacker's page, or the attacker to be able to perform an XSS attack.

In case the target website uses POST instead of GET parameters for session management, the link can be replaced by an automatically submitting form (as we will see in section \ref{forms}) \cite{Kolsek2002,Bontrager2005}.

Note that, for a website to accept session IDs via GET or POST parameters, it does not have to do its session management via URL rewriting by default. Indeed, multiple frameworks provide URL rewriting as a fallback for browsers that don't support cookies, causing them to be vulnerable to session fixation via URL rewriting \cite{PHPURLrewriting,Condit2006,Holovaty2008}.

\subsubsection{Via cross-site scripting}

If an attacker is able to inject script code into the target site (using one of the methods described in section \ref{injecting-script}), he can use this script code to set or replace the \gls{session cookie} with the desired value. This is done by editing the \texttt{document}'s \texttt{cookie} property \cite{Kolsek2002} or by using the \texttt{cookie.write()} function \cite{Johns2011}.

\subsubsection{Via the \texttt{<meta>} tag}

When an attacker is unable to inject script code (for instance, because \texttt{<script>} tags are stripped from user input), it is often still possible to abuse returned user input for setting cookies. Instead of using JavaScript, the attacker can use the \gls{html} \texttt{<meta>} tag to set the cookie. For this, he injects the following line of HTML code into the target web page:
\begin{lstlisting}[language=HTML]
<meta http-equiv=Set-Cookie content="PHPSESSID=d9qX4zKbg35">
\end{lstlisting}
where the name and value of the session cookie are chosen by the attacker \cite{Kolsek2002}.

\subsubsection{Via HTTP response splitting / header injection}\label{splitting}

There is another attack which can be used by an attacker to inject a cookie on the victim's machine. In an HTTP response splitting attack, the attacker tricks the victim's browser (or an in-between proxy) into thinking that two HTTP responses were sent by the target server, whereas both are actually part of the same HTTP response \cite{Klein2004}. The interesting part for the attacker is that the contents of one of the two responses can be chosen by himself. Because of this, an attacker is able to insert a \texttt{Set-Cookie} header containing the desired session identifier into the response, effectively injecting the SID into the client's browser \cite{Johns2011}.

\subsubsection{Via an active man-in-the-middle attack}

In an active man-in-the-middle attack, the attacker can not only eavesdrop on the victim's communication with the server, but can also intentionally modify this communication. This is the case, for example, when the attacker is able to take over the victim's gateway to the Internet (e.g. an Internet router or a proxy).

Since an active \gls{mitm} is able to modify responses from the server to the victim, he can alter the \texttt{Set-Cookie} header such that it contains the desired session identifier. The victim's browser will see this as the server issuing a new session cookie, and will store the cookie accordingly.

\subsubsection{Via subdomain cookie setting}\label{subdomain-setting}

Sometimes, an attacker is able to take over a subdomain of the target website because it is more vulnerable than the parent domain, or because he has legitimate access on the subdomain. Normally, setting a cookie on a subdomain would not have any effect on the parent domain. Indeed, as we described in section \ref{access-control}, cookies will only be used for the same domain as the one that set them, or for one of its subdomains. Thus, a cookie set on a subdomain will not be used for its parent domain. This makes it seem like performing a session fixation attack on a parent domain is not possible from within a subdomain.

There is, however, the possibility to set a cookie for a parent domain by using the cookie's \texttt{domain} parameter \cite{Kristol2001}. As an example, consider the case where the attacker is able to take over the domain \texttt{vulnerable.target.com}. He can then use this domain to set a cookie for \texttt{target.com}, and all of its subdomains, by specifying the cookie as \texttt{PHPSESSID=d9qX4zKbg35;domain=.target.com} (notice the `\texttt{.}' preceding \texttt{target.com}). This effectively allows an attacker that has access to a subdomain to execute a session fixation attack on a parent domain \cite{Kolsek2002}.

A related problem occurs when two cookies with the same name are set for both the parent domain and the subdomain. When the user visits a page on the subdomain, his browser will attach both cookies to the request. Unfortunately, since cookies don't contain the \texttt{domain} attribute when they are sent from the client to the server, the server has no way of distinguishing between the parent domain and the subdomain cookie. What makes matters worse is that the order in which both cookies are sent differs between browsers. We tested the behavior of the Firefox, Opera and Chrome browsers, and found that:
\begin{itemize}
	\item Firefox sends the subdomain cookie first, and the parent domain cookie second.
	\item Opera sends the parent domain cookie first, and the subdomain cookie second.
	\item Chrome sends the cookies in alphabetical order, regardless of their domain.
\end{itemize}
It has been proposed that cookies include their attributes when they are sent to the server \cite{rfc2965}. Unfortunately, as we can see from the previous results, this standard has not yet been widely implemented, even though it has existed for over a decade already.

\subsection{Other dangers of session fixation}

It seems that the only benefit an attacker has from performing a session fixation attack is that he can take over the session of another user. There is, however, another issue: an attacker is also able to force a victim to be logged in under the attacker's account. He can do this by logging in first, and subsequently forcing the victim to use the attacker's session ID. This has two major implications \cite{Barth2008}:
\begin{itemize}
	\item An attacker can track the victim's actions on the target web application by making use of logging functionality offered by this application. For example, most major search engines offer the option to log the user's search history\footnote{Google, for example, offers an overview of all your searched queries at \url{http://www.google.com/searchhistory/}.}, allowing an attacker who is able to perform a session fixation attack to access this highly sensitive information \cite{Barbaro2006}.
	\item On domains that allow the embedding of trusted scripts, it creates the ability for an attacker to execute \gls{xss} attacks. Until recently, iGoogle\footnote{\url{http://www.google.com/ig}} offered the ability to embed trusted scripts on your own personal homepage \cite{Barth2008}. Because of this, an attacker who is able to perform a session fixation attack has the ability to offer scripts to a victim from within the \texttt{google.com} domain. He does this by adding a script to his own homepage, and subsequently imposing his own SID upon the victim's browser. Thus, the next time the victim visits iGoogle, the attacker's home page will be loaded, and the script will be executed from within the \texttt{google.com} domain.
\end{itemize}
A distinction must be made between the previously described scenario, wherein an attacker tricks the user into logging in with a predefined SID, and the scenarios described in this section. We will use the term \emph{\gls{login session fixation}} to refer to the first variation, while using just \emph{session fixation} to refer to the general class of session fixation attacks.

\section{Cross Site Request Forgery}\label{csrf}

The cross site request forgery (also called \gls{csrf} or session riding) attack is different from the \gls{session hijacking} and \gls{session fixation} attacks in the sense that an attacker executing a CSRF attack does not try to completely take over a victim's session. Instead, the attack leverages the victim's browser's implicit authentication to make requests in the name of the client. This is accomplished by compelling the victim's browser into issuing a request. A possible threat exists, for example, when the victim is logged in at the website of his bank. In this case, the attacker can use the victim's implicit authentication to transfer money from the victim's account to his own account. Before we see the ways in which the attacker can make a victim's browser issue requests, let us first look at the complete attack scenario.

\subsection{Attack scenario}

The CSRF attack is made up out of the following steps (assuming that the victim is already authenticated at the target website) \cite{Schreiber2004}:

\begin{enumerate}
	\item The attacker forces the victim's browser to send a request to the server (we will see how this happens in the next section). It is the attacker that chooses the contents of this request.
	\item The browser, thinking that a legitimate request is performed by the victim, automatically attaches the victim's authentication information. This authentication information can be in the form of a \gls{sid}, \gls{http} \texttt{Auth} credentials, \gls{ssl} information, or even the user's \gls{ip} address \cite{Johns2006b,Zeller2008}.
	\item The browser sends the request to the target server. This server uses the request's authentication information to determine that the request was made by the victim. Thus, the server executes any action that was requested by the attacker as if the victim requested it.
\end{enumerate}

The different steps of the CSRF attack are graphically illustrated in Figure \ref{fig:csrf}.

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.50\textwidth]{img/csrf.png}
	\caption{The cross site request forgery attack}
	\label{fig:csrf}
\end{figure}

\subsection{Forcing the browser to make a request}\label{forcing-request}

As was the case with the previous attacks, there are several possibilities to execute a CSRF attack. In this section, we describe the most important methods an attacker can use for compelling the victim's browser into issuing a cross-site request.

\subsubsection{Via the \texttt{<img>} tag}

The \texttt{<img>} \gls{html} tag is normally used for including images in a web page. However, the \texttt{<img>} tag can also be abused by an attacker for issuing cross-site requests. For this, instead of providing the URL to an actual image, the attacker provides a request URL containing GET parameters. This will cause the victim's browser to issue the request when it tries to load the image as part of the current page \cite{Johns2006b}. If the attacker is able to insert images into a trusted website (as is often the case in bulletin boards), he can make a victim issue the request when he visits the trusted page containing the image \cite{Barth2008}. The \texttt{<img>} tag can only be abused by an attacker for issuing requests that contain GET parameters.

\subsubsection{Via cascading style sheets}

Cascading style sheets (or \gls{css}, not to be confused with \gls{xss}) are used for defining the appearance of a web page. They include the colors, fonts, and placements for elements on a web page. Similar to using the \texttt{<img>} tag for issuing requests, the \texttt{<link>} tag, which is normally used to load external CSS styles can be used to issue requests \cite{Huang2010}. For this, the attacker sets the URL of the style sheet to the request URL containing the GET parameters. This will cause the victim's browser to issue the request when it tries to load the style sheet for the page. As was the case with the previous method, cascading style sheets can only be abused for issuing requests that contain GET parameters.

\subsubsection{Via forms}\label{forms}

When the target web application uses POST instead of GET parameters for the request the attacker wants to execute, an HTML form can be used to perform the request. When a form is submitted, the browser issues a request containing the form elements with their values as POST parameters.

An attacker can create a form containing elements that have the desired values. He must then force the victim's browser to submit the form, which can be done by either tricking the victim into submitting the form manually, or by having the form submit automatically using JavaScript.

Tricking the victim into submitting the form can be relatively easy: all the attacker has to do is assure that the victim will click the submit button. This can be achieved by hiding all form elements except for the submit button, and making it seem like the button serves some other purpose. This approach is taken even further by Mao et al. \cite{Mao2009}: they noticed that, even when it is required that the \emph{actual} submit button of the trusted site is pressed (as is the case when some CSRF countermeasures \cite{Jovanovic2006,Johns2006} are in place), a victim can still be tricked into triggering the browser to make a request that he did not want it to perform. This is done by including an iframe\footnote{An iframe is an HTML tag which allows a HTML page to be embedded within a parent HTML document.} containing the original form into the attacker's website, while making only the form's `post' button visible to the victim. The hiding of other parts of the form is achieved by resizing and auto-scrolling the iframe. The result of executing such an attack in order to make a victim unwillingly post something on his own Facebook profile page is shown in Figure \ref{fig:mao2009}.

\begin{figure}[htb]
	\centering
	\subfloat[the original form]{
		\includegraphics{img/mao2009a.png}
	}
	\subfloat[a malicious page including only parts of the form in an iframe, trying to trick a user into clicking the button]{
		\includegraphics{img/mao2009b.png}
	}
	\caption[Tricking a user into submitting a form]{Tricking a user into submitting a form \cite{Mao2009}}
	\label{fig:mao2009}
\end{figure}

An attacker can also make the form automatically submit in the victim's browser. For this, he needs JavaScript capabilities on the page where the form is located. An attacker has these capabilities when the form is hosted on the attacker's domain (which then needs to be visited by the victim), or when the form is displayed on a page where the attacker can execute an \gls{xss} attack (see section \ref{xss}). To access the form, the attacker can use the \texttt{forms} \gls{dom} element, which contains a list of all forms on the page. Automatically submitting the form can then be done by inserting a line of JavaScript similar to
\begin{lstlisting}[language=HTML]
<script> document.forms[0].submit() </script>
\end{lstlisting}
into the HTML code of the page \cite{Jovanovic2006}.

\subsubsection{CSRF and the same origin policy}

The \gls{sop} (described in section \ref{sop}) limits JavaScript access to DOM objects that have the same origin as the page which contains the script. Although this prevents JavaScript from accessing DOM objects from another domain, it does not prevent JavaScript from making requests to another domain \cite{DeRyck2010}. Thus, the same origin policy does not have any effect on CSRF attacks.

\subsection{Other ways of forcing the browser to make a request}\label{other-browser-requests}

Technically, cross site request forgery attacks always automatically issue a request to a different domain. In this section, we describe some other methods an attacker can use to make a victim's browser issue a request. Note that, although these methods can be associated with cross site request forgery attacks, they are technically different, because they do not issue a request from one domain to a different domain, or because they can not be used to issue a request automatically.

\subsubsection{Via crafted URLs}

The simplest method for an attacker to make a victim's browser issue a request is to trick the victim into clicking a crafted an \gls{url} containing the desired request and its GET parameters. When the victim clicks the URL, the browser will automatically issue the request together with its parameters. Tricking the user into clicking the URL can be done either by \gls{phishing} \cite{Dhamija2006}, or by embedding the URL in a trusted web page in a manner similar to the \gls{xss} attack described in section \ref{xss}. Because URLs can only hold GET parameters, this method can not be used for issuing requests that contain POST parameters.

\subsubsection{Via asynchronous requests}\label{asynch}

If the attacker is able to perform an \gls{xss} attack, he can inject JavaScript code which uses the \texttt{XMLHttpRequest} object to perform an asynchronous HTTP request. The complete specification of this object is available at \cite{Kesteren:09:X}. We only provide the following small example of its use \cite{Binny2010}:
\begin{lstlisting}[language=JavaScript,breaklines=true]
var client = new XMLHttpRequest();
client.open("POST", "transfer.php");
params = "to=attacker&amount=50000";
client.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
client.setRequestHeader("Content-length", params.length);
client.setRequestHeader("Connection", "close");
client.send(params);
\end{lstlisting}
An asynchronous GET request can be made in a similar fashion. Differences are that the parameters are now appended to the URL instead of passed to the \texttt{send()} function, and that the HTTP headers don't have to be explicitly set.

\subsubsection{Via an active man-in-the-middle attack}

An active network attacker (or `active \gls{mitm}') does not need the victim's browser to submit the request: he can simply modify any request sent by the victim to contain the URL and parameters he wants \cite{Barth2008}. However, as we noted when describing the session hijacking and session fixation attacks, an attacker is likely to have better options for attack when he is an active MitM. Indeed, an active attacker will always have the ability to intercept a victim's SID, causing him to be able to issue requests in name of the victim himself. 

\begin{table}[htb]
	\centering
	\begin{tabular}{r|cccc}
		& GET requests & POST requests & automatable & cross-domain\\
		\hline
		\texttt{<img>} tag & X & & X & X\\
		CSS & X & & X & X\\
		Form &  & X & X & X\\
		Crafted URL & X & & & X\\
		Async. request & X & X & X &\\
		Active MitM & X & X & & X
	\end{tabular}
	\caption{Comparison of different methods for forcing a browser to make a request}
	\label{tab:forcing-request}
\end{table}

Table \ref{tab:forcing-request} summarizes for each of the methods discussed in this and the previous section whether requests can be automated, and whether cross-domain requests are allowed to be made. The table also lists whether a certain method can be used to issue GET requests, POST requests, or both. As we noted in section \ref{get-or-post}, however, some websites which normally use one of those two methods also accept requests issued using the other method \cite{Zeller2008}.
